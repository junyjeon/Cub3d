효율과 투자는 다르다.

요구사항
 - 인자 2개
 - .cub
 - 맵이 바르지 못한 경우(뭔 경우임?)
 NO SO WE EA FLOOR CEIL MAP이 아닌경우. 0이나 NULL
 - 레이캐스팅
 

아이디어
- 레이캐스팅
 - 맵의 각 사각형(픽셀)은 가로 세로 높이가 같아야 함.
 - 바라보는 방향에 따라. x값이 1로 증가할지 -1로 증가할지 정함.
 - 사각형에 닿을 때까지 증감한다.
 - 닿으면 플레이어와 닿은 곳의 x좌표 cos() y좌표 sin()의 값에 따라 화면에 그릴 벽의 높이를 정한다.
 - 방향을 벡터로 만들기 위해 x, y를 같은 값으로 곱한다.(벽(벽(픽셀)과의 거리, 방향을 벡터로 만듬)
 ![Alt text](https://lodev.org/cgtutor/images/raycastingcamera.gif)
 - 카메라 평면(실제론 선) 벡터도 필요하다.
 - ->pos + ->dir (카메라 평면인 평면 벡터.), ->plane (시야각의 레이와의 거리)
 - (방향 벡터 == 평면 벡터) 이면 FOV는 90도가 된다.
 - (방향 벡터 < 2D화면) 이면 FOV는 90~180도
 - (방향 벡터 < 2D화면) 이면 FOV 0~90
 
 플레이어. 플레이어 위치. 각 사각형의 높이, 사각형과 플레이어 사이의 벡터,
 방향 벡터(x와 y에 같은 값 곱하기), 
 벡터 구성 완료.
 - 플레이어가 회전하면 카메라도 회전해야 하므로
   방향 벡터 평면 벡터가 같이 움직임 그럼 레이도 같이 회전함.
 - 벡터를 회전하려면 회전행렬을 곱함.
 [cos(a) - sin(a)]
 [sin(a) cos(a)]
	- 구성요소
		플레이어 = px, py;
		방향 벡터(dir) = px, py를 같은 값으로 곱
		카메라 평면 벡터(pos)
		DDA로 광선을 보내서 닿은 곳의 좌표를 sqrt(1 + (rayY * rayY / rayX * rayX))공식..?을 통해 연산한 뒤 높이 정한 걸 width만큼 반복하기
		수직거리 구하기 ???

parse_map보기