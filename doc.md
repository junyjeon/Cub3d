효율과 투자는 다르다.

요구사항
 - 인자 2개
 - .cub
 - 맵이 바르지 못한 경우(뭔 경우임?)
 NO SO WE EA FLOOR CEIL MAP이 아닌경우. 0이나 NULL
 - 레이캐스팅
 

아이디어
- 레이캐스팅
 - 맵의 각 사각형(픽셀)은 가로 세로 높이가 같아야 함.
 - 바라보는 방향에 따라. x값이 1로 증가할지 -1로 증가할지 정함.
 - 사각형에 닿을 때까지 증감한다.
 - 닿으면 플레이어와 닿은 곳의 x좌표 cos() y좌표 sin()의 값에 따라 화면에 그릴 벽의 높이를 정한다.
 - 방향을 벡터로 만들기 위해 x, y를 같은 값으로 곱한다.(벽(벽(픽셀)과의 거리, 방향을 벡터로 만듬)
 ![Alt text](https://lodev.org/cgtutor/images/raycastingcamera.gif)
 - 카메라 평면(실제론 선) 벡터도 필요하다.
 - ->pos + ->dir (카메라 평면인 평면 벡터.), ->plane (시야각의 레이와의 거리)
 - (방향 벡터 == 평면 벡터) 이면 FOV는 90도가 된다.
 - (방향 벡터 < 2D화면) 이면 FOV는 90~180도
 - (방향 벡터 < 2D화면) 이면 FOV 0~90
 
 플레이어. 플레이어 위치. 각 사각형의 높이, 사각형과 플레이어 사이의 벡터,
 방향 벡터(x와 y에 같은 값 곱하기), 
 벡터 구성 완료.
 - 플레이어가 회전하면 카메라도 회전해야 하므로
   방향 벡터 평면 벡터가 같이 움직임 그럼 레이도 같이 회전함.
 - 벡터를 회전하려면 회전행렬을 곱함.
 [cos(a) - sin(a)]
 [sin(a) cos(a)]
	- 구성요소
		플레이어 = px, py;
		방향 벡터(dir) = px, py를 같은 값으로 곱
		카메라 평면 벡터(pos)
		DDA로 광선을 보내서 닿은 곳의 좌표를 sqrt(1 + (rayY * rayY / rayX * rayX))공식..?을 통해 연산한 뒤 높이 정한 걸 width만큼 반복하기
		수직거리 구하기 ???

parse_map보기



1. 마우스 이벤트 처리
2. 회전 이벤트 처리
3. 플레이어의 시작 위치를 저장하는 로직
4. 색상 데이터를 검증하는 로직
5. 데이터 저장
6. 파일 확장자 검증, 파일 열기, 맵 유효성 검사 등의 로직

그려보기

1. argc 검사
2. map 구조체 초기화
3. 전처리
 - .cub 검사
 - 파일 open -> fd
 - 파일의 모든 라인 -> all_lines
 - 파일 close
 - 모든 라인 \n 기준 split
4. 메인처리
 - 한 줄씩 텍스쳐 파일 경로인지(NSWE 방향), 벽인지(F), 천장인지(C), 맵인지("01NSWE ") 검사
 - 경로 -> 파일 열기
 - 벽, 천장 -> RGB 유효성검사(0 <= data < 256안에 드는 숫자인지 0F1 이것도 숫자로 들어가지 않게 ft_digit사용 (0<= data <=9))
 - 맵 -> 따로 라인을 한 줄로 합침.(tmp_map)
5. 맵 파싱 (한 줄로 합친 라인(tmp_map))
 - 한 줄로 합친 라인 개행 기준으로 나누기
 - 나눈 맵에서 NSEW찾고 플레이어 위치pos, 방향 벡터dir, 카메라 방향 벡터plane 저장
 - 맵이 벽으로 둘러쌓여있는지 검사
6. game	구조체 초기화 하기.(사전작업)
 - SCREEN_WIDTH 개수 만큼 돌 camerax변수, DDA알고리즘에서 사용될 삼각형의 대각성 길이 x값에 닿는 벡터와 y에 닿는 벡터
7. 맵을 지운다.
8. 화면을 그린다.
9. 삼각형의 비율을 재어서 첫 시작의 대각선의 길이를 잰다.
10. 플레이어의 위치와 광선의 방향에 따라서 어디로 광선을 줄지 정한다.
11. dda알고리즘으로 광선을 쏜다.
12. 광선이 벽에 부딪힌 지점부터 플레이어 까지의 거리를 재어서 벽의 높이를 정한다.
13. ray가 부딪힌 벽의 색상 값을 선택해준다.
14. loop
 - 카메라 방향 벡터의 x값을 모두 보면서 광선의 방향 벡터 raydir을 계산한다.

읽다보니 map->col이 col의 최댓값을 저장해두는데, 맵의 이동할 수 있는 곳은 항상 map->col이 되고있다. 암튼 아무것도 없는 곳을 가려고 해서 터지는 세그폴트

레이캐스팅은 2차원 맵에서 3차원의 원금감을 만드는 렌더링 기술이다.

1. 2차원 정사각형 벽으로 둘러쌓인 맵이 있을 때.
2. 맵의 한칸은 0 or 양수를 갖고
	0 = 벽이 없음
	양수 = 벽이 있고 텍스쳐 이미지를 갖고 있다.
3. 화면(카메라 평면)의 모든 x값에 대해 플레이어 위치에서 부터 시작하는 RAY를 쏜다(쏜다는 개념이 무엇인가)
4. 광선의 방향은 플레이어가 바라보는 방향과 화면(카메라 평면)의 x값(광선의 시작)에 따라 다름
5. 벽(양수)에 부딪힐 때까지 직진(DDA알고리즘), 벽에 부딪히면 플레이어까지의 거리를 잰다.
6. 거리에 따라 벽의 높이가 달라지게 끔 값을 준다. (0 ~ 1 사잇값. 플레이어와 벽의 거리가 멀 수록 화면에 더 낮게 그린다)


//✅시작 위치 map->t_player posX, posY 초기화
//✅바라보는 방향 map->t_player start_sight 초기화
//방향 벡터 map->t_player dirX, dirY 초기화
//카메라 평면 벡터 planeX, planeY = 0.66 초기화
//FOV 1인친 슈팅게임에 적합한 비율(2 * atan(planeY/1.0)= 66°)
//키보드 왼쪽 오른쪽 키는 회전 행렬
//ESC키, red_cross_button 누르면 프로그램 종료.
//✅인수는 .cub마, 맵 구성은 NSEW 0 1 문자로만
//루프
//mlx그리는건

// 인자 수 확인
// 게임의 맵 초기화
// 제공된 파일에서 맵 데이터 파싱
/**
 * init 게임을 전체적으로 초기화 하는 함수
 * load_texture 텍스쳐 로딩
 * init_texture 게임에 사용될 텍스쳐 4개 초기화
 * init_img 스크린 이미지 초기화
 * init_mlx_win mlx, win 초기화
 * init_game 게임 관련 변수 초기화 
 */

/**
 * parse 전처리, 주요처리를 수행한 후 파싱된 맵을 반환
 * join_all_line 두 문자열을 합친 문자열을 반환
 * pre_processing 파일 확장자를 확인하고 파일의 모든 줄을 반환
 * - read_file 파일에서 한 줄씩 읽어 모든 문자열을 반환
 * - check_file_extension 파일 확장자를 확인하고 파일을 열어 파일 디스크립터를 반환
 * main_processing
 * - validate_line 각 줄의 유효성을 검증함
 * - parse_texture 텍스처 파일 경로를 파싱하고 반환
 * - parse_color RGB 색상 데이터를 파싱하고 색상 코드를 반환
 *   - check_color RGB 색상 포맷을 검증
 * parse_map
 * - parses_map_line 맵의 각 줄을 파싱하여 플레이어 위치, 방향, row, col을 결정
 *   - init_player 플레이어 위치, 방향 초기화
 * - create_visited 방문 셀을 추적하기 위한 map과 같은 2차원 배열 생성
 */

/**
 * 
 * 
 */

// 루프 로직 설정
// 키 입력 훅 설정
// 루프 실행

끝

**texture
**map

int			**visited;
char		**map;
char		*tmp_map;

ㄱㅏ
