효율과 투자는 다르다.

요구사항
 - 인자 2개
 - .cub
 - 맵이 바르지 못한 경우(뭔 경우임?)
 NO SO WE EA FLOOR CEIL MAP이 아닌경우. 0이나 NULL
 - 레이캐스팅
 

아이디어
- 레이캐스팅
 - 맵의 각 사각형(픽셀)은 가로 세로 높이가 같아야 함.
 - 바라보는 방향에 따라. x값이 1로 증가할지 -1로 증가할지 정함.
 - 사각형에 닿을 때까지 증감한다.
 - 닿으면 플레이어와 닿은 곳의 x좌표 cos() y좌표 sin()의 값에 따라 화면에 그릴 벽의 높이를 정한다.
 - 방향을 벡터로 만들기 위해 x, y를 같은 값으로 곱한다.(벽(벽(픽셀)과의 거리, 방향을 벡터로 만듬)
 ![Alt text](https://lodev.org/cgtutor/images/raycastingcamera.gif)
 - 카메라 평면(실제론 선) 벡터도 필요하다.
 - ->pos + ->dir (카메라 평면인 평면 벡터.), ->plane (시야각의 레이와의 거리)
 - (방향 벡터 == 평면 벡터) 이면 FOV는 90도가 된다.
 - (방향 벡터 < 2D화면) 이면 FOV는 90~180도
 - (방향 벡터 < 2D화면) 이면 FOV 0~90
 
 플레이어. 플레이어 위치. 각 사각형의 높이, 사각형과 플레이어 사이의 벡터,
 방향 벡터(x와 y에 같은 값 곱하기), 
 벡터 구성 완료.
 - 플레이어가 회전하면 카메라도 회전해야 하므로
   방향 벡터 평면 벡터가 같이 움직임 그럼 레이도 같이 회전함.
 - 벡터를 회전하려면 회전행렬을 곱함.
 [cos(a) - sin(a)]
 [sin(a) cos(a)]
	- 구성요소
		플레이어 = px, py;
		방향 벡터(dir) = px, py를 같은 값으로 곱
		카메라 평면 벡터(pos)
		DDA로 광선을 보내서 닿은 곳의 좌표를 sqrt(1 + (rayY * rayY / rayX * rayX))공식..?을 통해 연산한 뒤 높이 정한 걸 width만큼 반복하기
		수직거리 구하기 ???

parse_map보기



1. 마우스 이벤트 처리
2. 회전 이벤트 처리
3. 플레이어의 시작 위치를 저장하는 로직
4. 색상 데이터를 검증하는 로직
5. 데이터 저장
6. 파일 확장자 검증, 파일 열기, 맵 유효성 검사 등의 로직

그려보기

1. argc 검사
2. map 구조체 초기화
3. 전처리
 - .cub 검사
 - 파일 open -> fd
 - 파일의 모든 라인 -> all_lines
 - 파일 close
 - 모든 라인 \n 기준 split
4. 메인처리
 - 한 줄씩 텍스쳐 파일 경로인지(NSWE 방향), 벽인지(F), 천장인지(C), 맵인지("01NSWE ") 검사
 - 경로 -> 파일 열기
 - 벽, 천장 -> RGB 유효성검사(0 <= data < 256안에 드는 숫자인지 0F1 이것도 숫자로 들어가지 않게 ft_digit사용 (0<= data <=9))
 - 맵 -> 따로 라인을 한 줄로 합침.(tmp_map)
5. 맵 파싱 (한 줄로 합친 라인(tmp_map))
 - 한 줄로 합친 라인 개행 기준으로 나누기
 - 나눈 맵에서 NSEW찾고 플레이어 위치pos, 방향 벡터dir, 카메라 방향 벡터plane 저장
 - 맵이 벽으로 둘러쌓여있는지 검사
6. game	구조체 초기화 하기.
 - SCREEN_WIDTH 개수 만큼 돌 camerax변수, DDA알고리즘에서 사용될 삼각형의 대각성 길이 x값에 닿는 벡터와 y에 닿는 벡터
7. 
8. loop 화면 그리기
 - 카메라 방향 벡터의 x값을 모두 보면서 광선의 방향 벡터 raydir을 계산한다.


읽다보니 map->col이 col의 최댓값을 저장해두는데, 맵의 이동할 수 있는 곳은 항상 map->col이 되고있다. 암튼 아무것도 없는 곳을 가려고 해서 터지는 세그폴트